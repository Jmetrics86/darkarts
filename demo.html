<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Seven - Counter Management Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #0a0a0f; font-family: 'Cinzel', serif; color: #e0e0e0; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        
        .hud-top { background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent); padding: 20px; display: flex; justify-content: space-between; pointer-events: auto; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .hud-bottom { background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); padding: 30px; display: flex; flex-direction: column; align-items: center; pointer-events: auto; }
        
        .alignment-panel { background: rgba(10, 10, 15, 0.8); padding: 10px 20px; border-radius: 5px; border: 1px solid #333; min-width: 150px; }
        .light-glow { box-shadow: 0 0 15px rgba(0, 242, 255, 0.4); border-color: #00f2ff; }
        .dark-glow { box-shadow: 0 0 15px rgba(255, 0, 68, 0.4); border-color: #ff0044; }

        .phase-banner { text-align: center; margin-bottom: 15px; }
        .phase-title { font-size: 1.8rem; letter-spacing: 6px; text-transform: uppercase; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.8); }
        .phase-step { font-size: 0.9rem; color: #00f2ff; font-weight: bold; letter-spacing: 2px; height: 20px; transition: opacity 0.3s; text-shadow: 0 0 5px #00f2ff; }

        .btn { background: #1a1a1a; color: white; border: 1px solid #555; padding: 12px 40px; cursor: pointer; font-family: inherit; transition: 0.3s; pointer-events: auto; letter-spacing: 2px; text-transform: uppercase; font-weight: bold; }
        .btn:hover:not(:disabled) { background: #333; border-color: #00f2ff; box-shadow: 0 0 20px rgba(0,242,255,0.6); color: #00f2ff; }
        .btn:disabled { opacity: 0.3; cursor: default; }

        .widget-panel { position: absolute; right: 20px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 15px; pointer-events: auto; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; border: 1px solid #444; }
        .control-group { display: flex; flex-direction: column; align-items: center; gap: 5px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .control-group:last-child { border-bottom: none; }
        .control-label { font-size: 0.6rem; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        .control-val { font-size: 0.8rem; color: #00f2ff; font-weight: bold; }
        .zoom-btn { width: 40px; height: 40px; background: rgba(0,0,0,0.7); border: 1px solid #00f2ff; color: #00f2ff; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; border-radius: 5px; cursor: pointer; transition: 0.3s; }
        .zoom-btn:hover { background: #00f2ff; color: #000; box-shadow: 0 0 10px #00f2ff; }

        #msg-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; backdrop-filter: blur(5px); }
        
        .seal-indicator-strip { position: absolute; top: 120px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        .seal-node { width: 12px; height: 12px; border-radius: 50%; border: 1px solid #444; background: #111; transition: 0.5s; }
        .node-purified { background: #00f2ff; box-shadow: 0 0 10px #00f2ff; border-color: #fff; }
        .node-corrupted { background: #ff0044; box-shadow: 0 0 10px #ff0044; border-color: #fff; }
        .node-active { transform: scale(1.5); border-color: #fff; }

        .tooltip { 
            position: absolute; 
            padding: 15px; 
            background: rgba(10,10,20,0.95); 
            border: 1px solid #00f2ff; 
            border-radius: 4px; 
            pointer-events: none; 
            opacity: 0; 
            transition: 0.2s; 
            font-size: 0.9rem; 
            z-index: 20; 
            color: #fff; 
            box-shadow: 0 0 15px rgba(0,242,255,0.4);
            min-width: 280px;
            max-width: 380px;
        }
        .tooltip-ability { 
            color: #8ff; 
            font-style: italic; 
            border-top: 1px solid rgba(255,255,255,0.1); 
            margin-top: 10px; 
            padding-top: 10px; 
            font-size: 0.8rem;
            line-height: 1.4;
        }
        .deck-counter { font-size: 0.6rem; color: #aaa; margin-top: 5px; letter-spacing: 1px; }

        /* Counter Selection UI */
        #counter-overlay {
            position: absolute;
            top: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            border: 2px solid #00f2ff;
            padding: 20px;
            text-align: center;
            display: none;
            pointer-events: auto;
            z-index: 50;
            min-width: 300px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.5);
        }
        .counter-pool-item { display: inline-block; margin: 10px; padding: 10px; border: 1px solid #444; border-radius: 5px; }
        .power-marker-text { color: #00f2ff; font-weight: bold; font-size: 1.2rem; }
        .weakness-marker-text { color: #ff0044; font-weight: bold; font-size: 1.2rem; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="ui">
        <div class="hud-top">
            <div class="alignment-panel dark-glow">
                <div style="color: #ff0044; font-size: 0.7rem;">PLAYER 2 (DARKNESS)</div>
                <div id="p2-score" style="font-size: 1.8rem">0 / 7</div>
                <div id="p2-deck-count" class="deck-counter">DECK: 49</div>
            </div>
            <div style="text-align: center">
                <div id="round-indicator" style="font-size: 1.2rem; margin-bottom: 5px;">ROUND 1</div>
                <div id="game-status" style="font-size: 0.7rem; color: #aaa; text-transform: uppercase; letter-spacing: 1px;">Awaiting Command</div>
            </div>
            <div class="alignment-panel light-glow" style="text-align: right">
                <div style="color: #00f2ff; font-size: 0.7rem;">PLAYER 1 (LIGHT)</div>
                <div id="p1-score" style="font-size: 1.8rem">0 / 7</div>
                <div id="p1-deck-count" class="deck-counter">DECK: 49</div>
            </div>
        </div>

        <div id="counter-overlay">
            <div id="counter-title" style="font-size: 1rem; margin-bottom: 10px;">Allocate Counters</div>
            <div style="display:flex; justify-content: center; gap: 20px;">
                <div id="power-pool-box" class="counter-pool-item">
                    <div style="font-size: 0.6rem; color: #888;">POWER MARKERS</div>
                    <div id="power-pool-val" class="power-marker-text">0</div>
                </div>
                <div id="weakness-pool-box" class="counter-pool-item">
                    <div style="font-size: 0.6rem; color: #888;">WEAKNESS</div>
                    <div id="weakness-pool-val" class="weakness-marker-text">0</div>
                </div>
            </div>
            <div style="font-size: 0.7rem; color: #aaa; margin-top: 10px;">Click cards on the board to apply.</div>
            <button id="finish-counters-btn" class="btn" style="margin-top: 15px; padding: 5px 20px;">Done</button>
        </div>

        <div class="seal-indicator-strip" id="seal-nodes">
            <div class="seal-node"></div><div class="seal-node"></div><div class="seal-node"></div>
            <div class="seal-node"></div><div class="seal-node"></div><div class="seal-node"></div>
            <div class="seal-node"></div>
        </div>

        <div class="widget-panel">
            <div class="control-group">
                <span class="control-label">Camera Zoom</span>
                <div style="display:flex; gap:5px">
                    <button class="zoom-btn" onclick="zoomCamera(-5)">+</button>
                    <button class="zoom-btn" onclick="zoomCamera(5)">−</button>
                </div>
            </div>
            <div class="control-group">
                <span class="control-label">Hand Tilt</span>
                <span id="val-tilt" class="control-val">0.85</span>
                <div style="display:flex; gap:5px">
                    <button class="zoom-btn" onclick="adjustTuning('tilt', 0.05)">+</button>
                    <button class="zoom-btn" onclick="adjustTuning('tilt', -0.05)">−</button>
                </div>
            </div>
            <div class="control-group">
                <span class="control-label">Hand Height</span>
                <span id="val-height" class="control-val">12.0</span>
                <div style="display:flex; gap:5px">
                    <button class="zoom-btn" onclick="adjustTuning('height', 0.5)">↑</button>
                    <button class="zoom-btn" onclick="adjustTuning('height', -0.5)">↓</button>
                </div>
            </div>
            <div class="control-group">
                <span class="control-label">Hand Distance</span>
                <span id="val-dist" class="control-val">21.0</span>
                <div style="display:flex; gap:5px">
                    <button class="zoom-btn" onclick="adjustTuning('dist', -0.5)">Forward</button>
                    <button class="zoom-btn" onclick="adjustTuning('dist', 0.5)">Back</button>
                </div>
            </div>
        </div>

        <div id="card-tooltip" class="tooltip"></div>

        <div class="hud-bottom">
            <div class="phase-banner">
                <div id="phase-step-label" class="phase-step"></div>
                <div id="phase-name-label" class="phase-title">Prep Phase</div>
            </div>
            <div id="instruction-text" style="color: #ddd; margin-bottom: 20px; font-style: italic; min-height: 1.2rem; text-shadow: 0 1px 2px #000;"></div>
            <button id="main-action-btn" class="btn">End Prep Phase</button>
        </div>
    </div>

    <div id="msg-overlay">
        <h1 id="msg-title" style="font-size: 3rem; margin: 0;"></h1>
        <p id="msg-body" style="font-size: 1.2rem; color: #aaa; max-width: 600px; text-align: center; margin: 20px 0;"></p>
        <button id="restart-btn" class="btn">Begin New Cycle</button>
    </div>

    <script>
        /**
         * ENDLESS SEVEN ENGINE - FULL MANIFEST DATA
         */
        const LIGHT_POOL = [
            { name: "The Spinner", faction: "Light", type: "Avatar", power: 9, isChampion: true, ability: "Flip: Gain +1 Power Marker for every Light card currently in play.", markerPower: 0, needsAllocation: true },
            { name: "The Allotter", faction: "Light", type: "Avatar", power: 9, isChampion: true, ability: "Flip: Destroy card on any Seal. Activate: Destroy any one Marker type." },
            { name: "Prophet", faction: "Light", type: "Avatar", power: 9, isChampion: true, ability: "Passive: Prevents Purified Seals from being Corrupted while in play." },
            { name: "The Inevitable", faction: "Light", type: "Avatar", power: 9, isChampion: true, ability: "Post-Combat: After destroying a creature, gain 2 Power Markers." },
            { name: "Saint Michael", faction: "Light", type: "Avatar", power: 10, isChampion: true, ability: "Win Con: Activate with 5+ Seals. Final Act: Target battled card loses 3 Power." },
            { name: "Martyr", faction: "Light", type: "Avatar", power: 9, isChampion: true, ability: "Limbo Trigger: Purify one Neutral Seal without a Champion." },
            { name: "The Almighty", faction: "Light", type: "God", power: 15, isChampion: true, ability: "Flip: Purify a Corrupted Seal without a Champion. Activate: Destroy any one Marker type." },
            { name: "Archangel", faction: "Celestial", type: "Creature", power: 2, isChampion: false, ability: "Flip: Nullify enemy Flip ability here." },
            { name: "Cherubim", faction: "Celestial", type: "Creature", power: 4, isChampion: false, ability: "Flip: Return target creature in play to owner's deck." },
            { name: "Fallen One", faction: "Celestial", type: "Creature", power: 6, isChampion: false, ability: "Haste: Resolve battle before Flip." },
            { name: "Herald", faction: "Celestial", type: "Creature", power: 5, isChampion: false, ability: "Flip: Gain Power Markers equal to the top card of your deck.", markerPower: 5, needsAllocation: true },
            { name: "Nephilim", faction: "Celestial", type: "Creature", power: 3, isChampion: false, ability: "Flip: Battle invulnerability this round." },
            { name: "Seraphim", faction: "Celestial", type: "Creature", power: 7, isChampion: false, ability: "Passive: Protects others while Champion." },
            { name: "Thrones", faction: "Angel", type: "Creature", power: 1, isChampion: false, ability: "Flip: Change Influence of empty Seal." },
            { name: "Alpha", faction: "Lycan", type: "Creature", power: 7, isChampion: false, ability: "Haste: Combat first. Gain 2 Power Markers after victory.", markerPower: 2, needsAllocation: true },
            { name: "Beta", faction: "Lycan", type: "Creature", power: 6, isChampion: false, ability: "Flip: Battle invulnerability. Buff adjacent unit +2." },
            { name: "Omega", faction: "Lycan", type: "Creature", power: 5, isChampion: false, ability: "Flip: +1 Power Marker for every Lycan in Play.", markerPower: 1, needsAllocation: true },
            { name: "Sentinel", faction: "Lycan", type: "Creature", power: 4, isChampion: false, ability: "Flip: Target card loses 2 Power.", markerWeakness: 2, needsAllocation: true },
            { name: "Delta", faction: "Lycan", type: "Creature", power: 3, isChampion: false, ability: "Flip: Buff 3 cards +1 Power each.", markerPower: 3, needsAllocation: true },
            { name: "Luna", faction: "Lycan", type: "Creature", power: 2, isChampion: false, ability: "Final Act: Nullify enemy Influence change." },
            { name: "Wild Wolf", faction: "Lycan", type: "Creature", power: 1, isChampion: false, ability: "Haste: Resolve combat first." }
        ];

        const DARK_POOL = [
            { name: "Death", faction: "Darkness", type: "Horseman", power: 9, isChampion: true, ability: "Flip: Target card loses 5 Power.", markerWeakness: 5, needsAllocation: true },
            { name: "Famine", faction: "Darkness", type: "Horseman", power: 9, isChampion: true, ability: "Flip: Destroy any card in play." },
            { name: "Pestilence", faction: "Darkness", type: "Horseman", power: 9, isChampion: true, ability: "Flip: All enemy creatures lose 2 Power.", markerWeakness: 2, needsAllocation: true },
            { name: "War", faction: "Darkness", type: "Horseman", power: 9, isChampion: true, ability: "Post-Combat: Gain 3 Power Markers after destroying a creature.", markerPower: 3, needsAllocation: true },
            { name: "Lilith", faction: "Darkness", type: "Avatar", power: 10, isChampion: true, ability: "Win Con: Activate with 5+ Seals." },
            { name: "Hades", faction: "Darkness", type: "Avatar", power: 9, isChampion: true, ability: "Flip: Gain 2 Power Markers.", markerPower: 2, needsAllocation: true },
            { name: "The Destroyer", faction: "Darkness", type: "God", power: 15, isChampion: true, ability: "Flip: Corrupt Purified Seals without Champions." },
            { name: "Wrath", faction: "Daemon", type: "Creature", power: 7, isChampion: false, ability: "Flip: Enemy loses 1 Power.", markerWeakness: 1, needsAllocation: true },
            { name: "Pride", faction: "Daemon", type: "Creature", power: 6, isChampion: false, ability: "Flip: Card across loses 3 Power.", markerWeakness: 3, needsAllocation: true },
            { name: "Greed", faction: "Daemon", type: "Creature", power: 5, isChampion: false, ability: "Flip: Battle invulnerability." },
            { name: "Sloth", faction: "Daemon", type: "Creature", power: 4, isChampion: false, ability: "Flip: Target card loses 3 Power.", markerWeakness: 3, needsAllocation: true },
            { name: "Envy", faction: "Daemon", type: "Creature", power: 3, isChampion: false, ability: "Flip: Target card loses 3 Power.", markerWeakness: 3, needsAllocation: true },
            { name: "Lust", faction: "Daemon", type: "Creature", power: 2, isChampion: false, ability: "Flip: Forced mutual sacrifice." },
            { name: "Gluttony", faction: "Daemon", type: "Creature", power: 1, isChampion: false, ability: "Flip: Siphon all Power Markers." },
            { name: "Lord", faction: "Vampyre", type: "Creature", power: 7, isChampion: false, ability: "Flip: Gain 1 Power Marker for each Vampyre.", markerPower: 1, needsAllocation: true },
            { name: "Duke", faction: "Vampyre", type: "Creature", power: 6, isChampion: false, ability: "Flip: Card across loses 2 Power.", markerWeakness: 2, needsAllocation: true },
            { name: "Elder", faction: "Vampyre", type: "Creature", power: 5, isChampion: false, ability: "Haste: Resolve combat first." },
            { name: "Noble", faction: "Vampyre", type: "Creature", power: 4, isChampion: false, ability: "Flip: Target card loses 2 Power.", markerWeakness: 2, needsAllocation: true },
            { name: "Regent", faction: "Vampyre", type: "Creature", power: 3, isChampion: false, ability: "Flip: Change Influence of empty Seal." },
            { name: "Baron", faction: "Vampyre", type: "Creature", power: 2, isChampion: false, ability: "Flip: Nullify Flip here." },
            { name: "Fledgeling", faction: "Vampyre", type: "Creature", power: 1, isChampion: false, ability: "Flip: Gain 3 Power Markers.", markerPower: 3, needsAllocation: true }
        ];

        const SEVEN = 7;
        const SLOT_SPACING = 3.8;
        const CARD_W = 2.2;
        const CARD_H = 3.2;
        
        let tuning = { tilt: 0.85, height: 12.0, dist: 21.0 };
        let scene, camera, renderer, raycaster, mouse;
        let cameraTarget = new THREE.Vector3(0, 0, -2); 
        
        let seals = []; 
        let playerBattlefield = Array(SEVEN).fill(null);
        let enemyBattlefield = Array(SEVEN).fill(null);
        let playerHand = [];
        let playerLimbo = [];
        let enemyLimbo = [];

        // Logical Decks
        let playerDeck = [];
        let enemyDeck = [];
        
        let currentRound = 1;
        let currentPhase = 'PREP'; 
        let selectedObject = null;
        let activeSelection = null;
        let isProcessing = false;

        // Counter State
        let pendingPowerPool = 0;
        let pendingWeaknessPool = 0;
        let allocationCallback = null;

        let playerDeckMesh, enemyDeckMesh, playerLimboMesh, enemyLimboMesh, floorMesh;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);
            scene.fog = new THREE.Fog(0x0a0a0f, 20, 100);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 28, 32);
            camera.lookAt(cameraTarget);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            setupLighting();
            createTabletop();
            
            playerDeck = buildDeck(LIGHT_POOL, "Avatar", "God");
            enemyDeck = buildDeck(DARK_POOL, "Avatar", "God");

            startPrepPhase();

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);
            document.getElementById('main-action-btn').addEventListener('click', handleMainAction);
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            document.getElementById('finish-counters-btn').addEventListener('click', finishCounters);

            animate();
        }

        function buildDeck(pool, singleTypeA, singleTypeB) {
            let deck = [];
            pool.forEach(card => {
                let copies = (card.type === singleTypeA || card.type === singleTypeB) ? 1 : 3;
                for (let i = 0; i < copies; i++) { deck.push({ ...card }); }
            });
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function setupLighting() {
            const amb = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(amb);
            const sky = new THREE.PointLight(0x00f2ff, 1.8, 150);
            sky.position.set(0, 30, 10);
            scene.add(sky);
            const rim = new THREE.DirectionalLight(0xffffff, 0.8);
            rim.position.set(-15, 30, -15);
            scene.add(rim);
            const playerLight = new THREE.PointLight(0xffffff, 1.0, 60);
            playerLight.position.set(0, 20, 25);
            scene.add(playerLight);
        }

        function createTabletop() {
            floorMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(400, 400),
                new THREE.MeshPhongMaterial({ color: 0x08080c, shininess: 20 })
            );
            floorMesh.rotation.x = -Math.PI/2;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);

            const startX = -(SEVEN - 1) * SLOT_SPACING / 2;
            for (let i = 0; i < SEVEN; i++) {
                const x = startX + i * SLOT_SPACING;
                const hub = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.2, 1.25, 0.25, 6),
                    new THREE.MeshPhongMaterial({ color: 0x222222, emissive: 0x080808 })
                );
                hub.position.set(x, 0.1, 0);
                scene.add(hub);

                const light = new THREE.PointLight(0xffffff, 0, 12);
                light.position.set(x, 2, 0);
                scene.add(light);

                seals.push({ mesh: hub, light, alignment: 'NEUTRAL', champion: null, index: i });
                createGridSlot(x, 3.2, 0x333333); 
                createGridSlot(x, -3.2, 0x333333);
            }

            const startOriginX = -(SEVEN - 1) * SLOT_SPACING / 2;
            const deckOffset = startOriginX - 4;
            const limboOffset = (startOriginX + (SEVEN - 1) * SLOT_SPACING) + 4;

            playerDeckMesh = createPile(0x0077aa);
            playerDeckMesh.position.set(deckOffset, 0.2, 6);
            scene.add(playerDeckMesh);
            addLabel(playerDeckMesh, "DECK", 0x00f2ff);

            enemyDeckMesh = createPile(0xaa2233);
            enemyDeckMesh.position.set(deckOffset, 0.2, -6);
            scene.add(enemyDeckMesh);
            addLabel(enemyDeckMesh, "DECK", 0xff0044);

            playerLimboMesh = createPile(0x444444);
            playerLimboMesh.position.set(limboOffset, 0.05, 6);
            scene.add(playerLimboMesh);
            addLabel(playerLimboMesh, "LIMBO", 0xcccccc);

            enemyLimboMesh = createPile(0x444444);
            enemyLimboMesh.position.set(limboOffset, 0.05, -6);
            scene.add(enemyLimboMesh);
            addLabel(enemyLimboMesh, "LIMBO", 0xcccccc);
        }

        function createGridSlot(x, z, color) {
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(CARD_W + 0.2, CARD_H + 0.2),
                new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
            );
            mesh.rotation.x = -Math.PI/2;
            mesh.position.set(x, 0.06, z);
            scene.add(mesh);
        }

        function createPile(color) {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(CARD_W + 0.3, 0.1, CARD_H + 0.3), new THREE.MeshPhongMaterial({ color: 0x000000, transparent: true, opacity: 0.7 }));
            group.add(base);
            for(let i=0; i<6; i++) {
                const layer = new THREE.Mesh(new THREE.BoxGeometry(CARD_W, 0.05, CARD_H), new THREE.MeshPhongMaterial({ color }));
                layer.position.y = 0.05 + (i * 0.06);
                layer.rotation.y = (Math.random() - 0.5) * 0.15;
                group.add(layer);
            }
            return group;
        }

        function addLabel(parent, text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.font = 'bold 44px Cinzel'; ctx.textAlign = 'center'; ctx.fillText(text, 128, 48);
            ctx.font = 'bold 36px Arial'; ctx.fillText("--", 128, 90);
            const tex = new THREE.CanvasTexture(canvas);
            const label = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 1.75), new THREE.MeshBasicMaterial({ map: tex, transparent: true, color }));
            label.rotation.x = -Math.PI/2; label.position.y = 0.8;
            parent.add(label);
            parent.userData = { labelCanvas: canvas, labelTexture: tex, labelText: text };
        }

        function updateDeckLabel(mesh, count) {
            if (!mesh.userData.labelCanvas) return;
            const ctx = mesh.userData.labelCanvas.getContext('2d');
            ctx.clearRect(0,0,256,128);
            ctx.fillStyle = 'white'; ctx.font = 'bold 44px Cinzel'; ctx.textAlign = 'center'; ctx.fillText(mesh.userData.labelText, 128, 48);
            ctx.font = 'bold 40px Arial'; ctx.fillText(count, 128, 95);
            mesh.userData.labelTexture.needsUpdate = true;
        }

        function createCardMesh(data, isEnemy = false) {
            const group = new THREE.Group();
            const color = isEnemy ? 0x551111 : 0x113366;
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(CARD_W, 0.1, CARD_H),
                new THREE.MeshPhongMaterial({ color, emissive: color, emissiveIntensity: isEnemy ? 0.3 : 0.8 })
            );
            group.add(body);

            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 384;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = isEnemy ? '#200' : '#002'; ctx.fillRect(0,0,256,384);
            ctx.strokeStyle = isEnemy ? '#f66' : '#6ff'; ctx.lineWidth = 16; ctx.strokeRect(0,0,256,384);
            ctx.fillStyle = 'white'; ctx.font = 'bold 22px Cinzel'; ctx.textAlign = 'center'; ctx.fillText(data.name.toUpperCase(), 128, 50);
            ctx.font = '14px Cinzel'; ctx.fillStyle = isEnemy ? '#f88' : '#8ff'; ctx.fillText(data.faction, 128, 75);
            ctx.fillStyle = 'white'; ctx.font = 'bold 100px Cinzel'; ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 15; ctx.fillText(data.power, 128, 220);
            ctx.font = 'bold 30px Cinzel'; ctx.fillText(data.isChampion ? 'CHAMPION' : data.type.toUpperCase(), 128, 310);

            const tex = new THREE.CanvasTexture(canvas);
            const label = new THREE.Mesh(new THREE.PlaneGeometry(CARD_W * 0.95, CARD_H * 0.95), new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
            label.rotation.x = -Math.PI/2; label.position.y = 0.08;
            group.add(label);

            // Counter Containers (Visual)
            const pMark = new THREE.Group(); pMark.position.set(-0.8, 0.1, 1.2); group.add(pMark);
            const wMark = new THREE.Group(); wMark.position.set(0.8, 0.1, 1.2); group.add(wMark);

            group.userData = { ...data, isEnemy, faceUp: false, powerMarkers: 0, weaknessMarkers: 0, pMesh: pMark, wMesh: wMark };
            return group;
        }

        function updateCardVisualMarkers(card) {
            const ud = card.userData;
            // Clear existing
            while(ud.pMesh.children.length > 0) ud.pMesh.remove(ud.pMesh.children[0]);
            while(ud.wMesh.children.length > 0) ud.wMesh.remove(ud.wMesh.children[0]);

            for(let i=0; i<ud.powerMarkers; i++) {
                const dot = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00f2ff }));
                dot.position.y = i * 0.15;
                ud.pMesh.add(dot);
            }
            for(let i=0; i<ud.weaknessMarkers; i++) {
                const dot = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff0044 }));
                dot.position.y = i * 0.15;
                ud.wMesh.add(dot);
            }
        }

        async function startPrepPhase() {
            if (isProcessing) return;
            isProcessing = true; currentPhase = 'PREP';
            document.getElementById('phase-name-label').innerText = "Prep Phase";
            document.getElementById('main-action-btn').disabled = true;
            updateStepLabel("Step 1: Draw Hand");
            
            playerHand = []; 
            for (let i = 0; i < 8; i++) {
                if (playerDeck.length === 0) break;
                const cardData = playerDeck.pop();
                const card = createCardMesh(cardData, false);
                card.position.copy(playerDeckMesh.position);
                card.position.y += 2;
                scene.add(card); playerHand.push(card);
                const offset = (i - 3.5);
                gsap.to(card.position, { x: offset * 2.15, y: tuning.height, z: tuning.dist + (Math.abs(offset) * 0.3), duration: 0.6, ease: "power2.out" });
                gsap.to(card.rotation, { x: tuning.tilt, y: offset * 0.06, z: 0, duration: 0.6 });
                updateUICounters(); await sleep(100);
            }
            await sleep(300);
            updateStepLabel("Step 2: Shuffle Deck");
            await performShuffleAnimation();
            await sleep(300);
            updateStepLabel("Step 3: Strategic Reinforcement");
            document.getElementById('main-action-btn').disabled = false;
            document.getElementById('main-action-btn').innerText = "End Prep Phase";
            enemyReinforce();
            isProcessing = false;
        }

        async function performShuffleAnimation() {
            const layers = playerDeckMesh.children.filter(c => c.type === "Mesh" && c.geometry && c.geometry.type === "BoxGeometry");
            for(let i=0; i<4; i++) {
                layers.forEach((l) => { gsap.to(l.position, { x: (Math.random() - 0.5) * 1.8, z: (Math.random() - 0.5) * 1.8, duration: 0.15, yoyo: true, repeat: 1 }); });
                await sleep(150);
            }
        }

        function enemyReinforce() {
            const aiHandData = [];
            for (let i = 0; i < 8; i++) { if (enemyDeck.length > 0) aiHandData.push(enemyDeck.pop()); }
            const vacantSlots = [];
            for (let i = 0; i < SEVEN; i++) { if (!enemyBattlefield[i]) vacantSlots.push(i); }
            vacantSlots.sort((a, b) => {
                const score = (idx) => {
                    const seal = seals[idx];
                    if (seal.alignment === 'PURIFIED') return 3;
                    if (seal.alignment === 'NEUTRAL') return 2;
                    return 1;
                };
                return score(b) - score(a);
            });
            for (let i = 0; i < vacantSlots.length && aiHandData.length > 0; i++) {
                const slotIdx = vacantSlots[i];
                aiHandData.sort((a, b) => b.power - a.power);
                const cardData = aiHandData.shift();
                const card = createCardMesh(cardData, true);
                card.position.copy(enemyDeckMesh.position); card.rotation.x = Math.PI;
                scene.add(card); enemyBattlefield[slotIdx] = card;
                gsap.to(card.position, { x: (slotIdx - 3) * SLOT_SPACING, y: 0.1, z: -3.2, duration: 0.8, delay: i * 0.15 });
            }
            updateUICounters();
        }

        function updateUICounters() {
            document.getElementById('p1-deck-count').innerText = `DECK: ${playerDeck.length}`;
            document.getElementById('p2-deck-count').innerText = `DECK: ${enemyDeck.length}`;
            updateDeckLabel(playerDeckMesh, playerDeck.length);
            updateDeckLabel(enemyDeckMesh, enemyDeck.length);
        }

        function handleMainAction() { if (currentPhase === 'PREP' && !isProcessing) endPrep(); }

        function endPrep() {
            isProcessing = true; updateStepLabel("Finalizing Placements...");
            playerHand.forEach((card, i) => {
                playerLimbo.push(card);
                gsap.to(card.position, { x: playerLimboMesh.position.x, y: 0.2 + (playerLimbo.length * 0.05), z: playerLimboMesh.position.z, duration: 0.6, delay: i * 0.05, onComplete: () => { card.rotation.set(0, 0, 0); if (card.children[0]) card.children[0].material.emissiveIntensity = 0.3; } });
            });
            playerHand = []; activeSelection = null;
            setTimeout(() => { startResolution(); }, 800);
        }

        async function startResolution() {
            currentPhase = 'RESOLUTION';
            document.getElementById('main-action-btn').disabled = true;
            for (let i = 0; i < SEVEN; i++) { await resolveSeal(i); }
            checkVictory();
            if (currentPhase !== 'GAME_OVER') {
                currentRound++; document.getElementById('round-indicator').innerText = `ROUND ${currentRound}`;
                gsap.to(camera.position, { x: 0, y: 28, z: 32, duration: 1.5, ease: "power2.inOut" });
                gsap.to(cameraTarget, { x: 0, y: 0, z: -2, duration: 1.5, ease: "power2.inOut" });
                if (currentRound > 3) finalizeGame();
                else { isProcessing = false; startPrepPhase(); }
            }
        }

        async function resolveSeal(idx) {
            const seal = seals[idx];
            document.querySelectorAll('.seal-node').forEach(n => n.classList.remove('node-active'));
            document.querySelectorAll('.seal-node')[idx].classList.add('node-active');
            document.getElementById('phase-name-label').innerText = `Seal ${idx + 1}`;
            gsap.to(camera.position, { x: seal.mesh.position.x, y: 14, z: 14, duration: 1 });
            gsap.to(cameraTarget, { x: seal.mesh.position.x, y: 0, z: 0, duration: 1 });
            
            let pCard = playerBattlefield[idx];
            let eCard = enemyBattlefield[idx];
            
            updateStepLabel("Step A: The Flip");
            if (pCard) gsap.to(pCard.rotation, { x: 0, duration: 0.5 });
            if (eCard) gsap.to(eCard.rotation, { x: 0, duration: 0.5 });
            await sleep(800);

            // Step B: Counter Management
            updateStepLabel("Step B: Counter Allocation");
            if (pCard && pCard.userData.needsAllocation) {
                await allocateCounters(pCard, false);
            }
            if (eCard && eCard.userData.needsAllocation) {
                await allocateCounters(eCard, true);
            }

            updateStepLabel("Step C: Battle");
            if (pCard && seal.champion && seal.champion.userData.isEnemy) {
                const pPow = pCard.userData.power + pCard.userData.powerMarkers - pCard.userData.weaknessMarkers;
                const cPow = seal.champion.userData.power + seal.champion.userData.powerMarkers - seal.champion.userData.weaknessMarkers;
                if (pPow > cPow) { destroyToLimbo(seal.champion, true, idx, true); seal.champion = null; }
                else if (pPow < cPow) { destroyToLimbo(pCard, false, idx); pCard = null; }
                else { destroyToLimbo(seal.champion, true, idx, true); destroyToLimbo(pCard, false, idx); seal.champion = null; pCard = null; }
                await sleep(500);
            }
            if (eCard && seal.champion && !seal.champion.userData.isEnemy) {
                const ePow = eCard.userData.power + eCard.userData.powerMarkers - eCard.userData.weaknessMarkers;
                const cPow = seal.champion.userData.power + seal.champion.userData.powerMarkers - seal.champion.userData.weaknessMarkers;
                if (ePow > cPow) { destroyToLimbo(seal.champion, false, idx, true); seal.champion = null; }
                else if (ePow < cPow) { destroyToLimbo(eCard, true, idx); eCard = null; }
                else { destroyToLimbo(seal.champion, false, idx, true); destroyToLimbo(eCard, true, idx); seal.champion = null; eCard = null; }
                await sleep(500);
            }
            if (pCard && eCard) {
                const pPow = pCard.userData.power + pCard.userData.powerMarkers - pCard.userData.weaknessMarkers;
                const ePow = eCard.userData.power + eCard.userData.powerMarkers - eCard.userData.weaknessMarkers;
                if (pPow > ePow) { destroyToLimbo(eCard, true, idx); eCard = null; await handlePostBattleSiege(idx, pPow, true); }
                else if (ePow > pPow) { destroyToLimbo(pCard, false, idx); pCard = null; await handlePostBattleSiege(idx, ePow, false); }
                else { destroyToLimbo(pCard, false, idx); destroyToLimbo(eCard, true, idx); pCard = null; eCard = null; }
            } else if (pCard) { await handlePostBattleSiege(idx, pCard.userData.power + pCard.userData.powerMarkers - pCard.userData.weaknessMarkers, true); }
            else if (eCard) { await handlePostBattleSiege(idx, eCard.userData.power + eCard.userData.powerMarkers - eCard.userData.weaknessMarkers, false); }
            else { await handlePostBattleSiege(idx, 0, true); }
            await sleep(600);

            updateStepLabel("Step E: Ascension");
            const survivor = (playerBattlefield[idx]) ? playerBattlefield[idx] : ((enemyBattlefield[idx]) ? enemyBattlefield[idx] : null);
            if (survivor && survivor.userData.isChampion && !seal.champion) { ascendToSeal(survivor, idx); }
            await sleep(1000);
        }

        async function allocateCounters(card, isAI) {
            const data = card.userData;
            pendingPowerPool = data.markerPower || 0;
            pendingWeaknessPool = data.markerWeakness || 0;

            if (isAI) {
                // AI Logic: Put power on own unit/champion, weakness on enemy
                for (let i = 0; i < pendingPowerPool; i++) {
                    const targets = enemyBattlefield.filter(c => c !== null);
                    if (targets.length > 0) { targets[0].userData.powerMarkers++; updateCardVisualMarkers(targets[0]); }
                }
                for (let i = 0; i < pendingWeaknessPool; i++) {
                    const targets = playerBattlefield.filter(c => c !== null);
                    if (targets.length > 0) { targets[0].userData.weaknessMarkers++; updateCardVisualMarkers(targets[0]); }
                }
                pendingPowerPool = 0; pendingWeaknessPool = 0;
                return Promise.resolve();
            } else {
                currentPhase = 'COUNTER_ALLOCATION';
                document.getElementById('counter-overlay').style.display = 'block';
                document.getElementById('power-pool-val').innerText = pendingPowerPool;
                document.getElementById('weakness-pool-val').innerText = pendingWeaknessPool;
                
                return new Promise((resolve) => {
                    allocationCallback = resolve;
                });
            }
        }

        function finishCounters() {
            if (pendingPowerPool > 0 || pendingWeaknessPool > 0) {
                // Warning logic could go here
            }
            document.getElementById('counter-overlay').style.display = 'none';
            currentPhase = 'RESOLUTION';
            if (allocationCallback) allocationCallback();
            allocationCallback = null;
        }

        async function handlePostBattleSiege(idx, attackerPower, isPlayer) {
            const seal = seals[idx];
            const attacker = isPlayer ? playerBattlefield[idx] : enemyBattlefield[idx];
            if (seal.champion && seal.champion.userData.isEnemy === isPlayer) {
                const champPow = seal.champion.userData.power + seal.champion.userData.powerMarkers - seal.champion.userData.weaknessMarkers;
                if (attackerPower > champPow) { destroyToLimbo(seal.champion, !isPlayer, idx, true); seal.champion = null; claimSeal(idx, isPlayer ? 'PURIFIED' : 'CORRUPTED'); }
                else if (attackerPower < champPow) { if (attacker) destroyToLimbo(attacker, !isPlayer, idx); }
                else if (attackerPower === champPow && attackerPower > 0) { destroyToLimbo(seal.champion, !isPlayer, idx, true); if (attacker) destroyToLimbo(attacker, !isPlayer, idx); seal.champion = null; claimSeal(idx, 'NEUTRAL'); }
            } else if (!seal.champion && attackerPower > 0) { claimSeal(idx, isPlayer ? 'PURIFIED' : 'CORRUPTED'); }
        }

        function destroyToLimbo(card, isEnemy, idx, isChamp = false) {
            const limboPile = isEnemy ? enemyLimbo : playerLimbo;
            const limboMesh = isEnemy ? enemyLimboMesh : playerLimboMesh;
            limboPile.push(card);
            if (!isChamp) { if (isEnemy) enemyBattlefield[idx] = null; else playerBattlefield[idx] = null; }
            gsap.to(card.position, { x: limboMesh.position.x + (Math.random()-0.5), y: 0.2 + (limboPile.length * 0.05), z: limboMesh.position.z + (Math.random()-0.5), duration: 0.8, ease: "power2.inOut" });
            gsap.to(card.rotation, { x: 0, y: Math.random() * 0.5, z: 0, duration: 0.8 });
            if (card.children[0]) card.children[0].material.emissiveIntensity = 0.3;
        }

        function claimSeal(idx, status) {
            const seal = seals[idx]; seal.alignment = status;
            let color = 0x080808; if (status === 'PURIFIED') color = 0x00f2ff; if (status === 'CORRUPTED') color = 0xff0044;
            seal.mesh.material.emissive.setHex(color); seal.mesh.material.emissiveIntensity = status === 'NEUTRAL' ? 0.1 : 0.8;
            seal.light.color.setHex(color); seal.light.intensity = status === 'NEUTRAL' ? 0 : 3.5;
            document.querySelectorAll('.seal-node')[idx].className = 'seal-node ' + (status === 'PURIFIED' ? 'node-purified' : (status === 'CORRUPTED' ? 'node-corrupted' : ''));
            updateGlobalScores();
        }

        function ascendToSeal(card, idx) {
            if (card.userData.isEnemy) enemyBattlefield[idx] = null; else playerBattlefield[idx] = null;
            seals[idx].champion = card;
            gsap.to(card.position, { x: seals[idx].mesh.position.x, y: 0.6, z: 0, duration: 0.6, ease: "back.out" });
            if (card.children[0]) card.children[0].material.emissiveIntensity = 1.0;
        }

        function zoomCamera(val) { gsap.to(camera.position, { y: camera.position.y + (val * 0.7), z: camera.position.z + val, duration: 0.5, ease: "power2.out" }); }
        function adjustTuning(key, delta) { tuning[key] = parseFloat((tuning[key] + delta).toFixed(2)); document.getElementById(`val-${key}`).innerText = tuning[key]; rearrangeHand(); }

        function restartGame() {
            document.getElementById('msg-overlay').style.display = 'none';
            [...playerHand, ...playerLimbo, ...enemyLimbo, ...playerBattlefield, ...enemyBattlefield].forEach(card => { if (card) scene.remove(card); });
            seals.forEach(seal => { if (seal.champion) scene.remove(seal.champion); seal.champion = null; seal.alignment = 'NEUTRAL'; seal.mesh.material.emissive.setHex(0x080808); seal.light.intensity = 0; });
            document.querySelectorAll('.seal-node').forEach(node => node.className = 'seal-node');
            playerBattlefield = Array(SEVEN).fill(null); enemyBattlefield = Array(SEVEN).fill(null);
            playerDeck = buildDeck(LIGHT_POOL, "Avatar", "God"); enemyDeck = buildDeck(DARK_POOL, "Avatar", "God");
            currentRound = 1; document.getElementById('round-indicator').innerText = `ROUND 1`;
            document.getElementById('p1-score').innerText = `0 / 7`; document.getElementById('p2-score').innerText = `0 / 7`;
            gsap.to(camera.position, { x: 0, y: 28, z: 32, duration: 1.5 }); cameraTarget.set(0, 0, -2);
            isProcessing = false; updateUICounters(); startPrepPhase();
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const allCards = [...playerHand, ...playerBattlefield.filter(c => c !== null), ...enemyBattlefield.filter(c => c !== null), ...seals.map(s => s.champion).filter(c => c !== null)];
            const intersects = raycaster.intersectObjects(allCards, true);
            const tooltip = document.getElementById('card-tooltip');
            if (intersects.length > 0) {
                let card = intersects[0].object; while (card.parent && !allCards.includes(card)) card = card.parent;
                if (selectedObject !== card) {
                    if (selectedObject && playerHand.includes(selectedObject)) gsap.to(selectedObject.position, { y: tuning.height, duration: 0.2 });
                    if (playerHand.includes(card)) gsap.to(card.position, { y: tuning.height + 1.5, duration: 0.2 });
                    selectedObject = card; tooltip.style.opacity = 1; tooltip.style.left = event.clientX + 20 + 'px'; tooltip.style.top = event.clientY - 40 + 'px';
                    const data = card.userData;
                    const effPow = data.power + data.powerMarkers - data.weaknessMarkers;
                    tooltip.innerHTML = `<div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;">${data.name}</div><div style="color: ${data.isEnemy ? '#f88' : '#8ff'}; font-size: 0.7rem; letter-spacing: 1px; margin-bottom: 5px;">${data.faction.toUpperCase()} / ${data.isChampion ? 'CHAMPION' : data.type.toUpperCase()}</div><div style="font-size: 1.2rem; font-weight: bold; margin: 10px 0;">EFF. POWER: ${effPow} <span style="font-size: 0.7rem; font-weight: normal; color: #aaa;">(${data.power} +${data.powerMarkers} -${data.weaknessMarkers})</span></div><div class="tooltip-ability">${data.ability}</div>`;
                }
            } else {
                if (selectedObject && playerHand.includes(selectedObject)) gsap.to(selectedObject.position, { y: tuning.height, duration: 0.2 });
                selectedObject = null; tooltip.style.opacity = 0;
            }
        }

        function onMouseDown() {
            raycaster.setFromCamera(mouse, camera);
            
            // Interaction logic for Prep Phase vs Counter Phase
            if (currentPhase === 'PREP') {
                const handIntersects = raycaster.intersectObjects(playerHand, true);
                if (handIntersects.length > 0) {
                    let card = handIntersects[0].object; while (card.parent && !playerHand.includes(card)) card = card.parent;
                    if (activeSelection && activeSelection.children[0]) activeSelection.children[0].material.emissiveIntensity = 0.8;
                    activeSelection = card; if (activeSelection.children[0]) activeSelection.children[0].material.emissiveIntensity = 2.5;
                    return;
                }
                if (activeSelection) {
                    const tableIntersects = raycaster.intersectObjects([floorMesh]);
                    if (tableIntersects.length > 0) {
                        const intersect = tableIntersects[0];
                        if (intersect.point.z > 0.5 && intersect.point.z < 7.0) {
                            const startX = -(SEVEN - 1) * SLOT_SPACING / 2;
                            const idx = Math.round((intersect.point.x - startX) / SLOT_SPACING);
                            if (idx >= 0 && idx < SEVEN && !playerBattlefield[idx]) {
                                const card = activeSelection; playerHand = playerHand.filter(c => c !== card); playerBattlefield[idx] = card;
                                gsap.to(card.position, { x: (idx - 3) * SLOT_SPACING, y: 0.1, z: 3.2, duration: 0.5, ease: "power2.inOut" });
                                gsap.to(card.rotation, { x: Math.PI, y: 0, z: 0, duration: 0.5 });
                                if (card.children[0]) card.children[0].material.emissiveIntensity = 0.4;
                                activeSelection = null; rearrangeHand();
                            }
                        }
                    }
                }
            } 
            else if (currentPhase === 'COUNTER_ALLOCATION') {
                const allCards = [...playerBattlefield.filter(c => c !== null), ...enemyBattlefield.filter(c => c !== null), ...seals.map(s => s.champion).filter(c => c !== null)];
                const intersects = raycaster.intersectObjects(allCards, true);
                if (intersects.length > 0) {
                    let card = intersects[0].object; while (card.parent && !allCards.includes(card)) card = card.parent;
                    
                    if (pendingPowerPool > 0) {
                        card.userData.powerMarkers++;
                        pendingPowerPool--;
                    } else if (pendingWeaknessPool > 0) {
                        card.userData.weaknessMarkers++;
                        pendingWeaknessPool--;
                    }
                    document.getElementById('power-pool-val').innerText = pendingPowerPool;
                    document.getElementById('weakness-pool-val').innerText = pendingWeaknessPool;
                    updateCardVisualMarkers(card);
                }
            }
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        function updateStepLabel(txt) { const el = document.getElementById('phase-step-label'); el.style.opacity = 0; setTimeout(() => { el.innerText = txt; el.style.opacity = 1; }, 200); }
        function updateGlobalScores() { const p1 = seals.filter(s => s.alignment === 'PURIFIED').length; const p2 = seals.filter(s => s.alignment === 'CORRUPTED').length; document.getElementById('p1-score').innerText = `${p1} / 7`; document.getElementById('p2-score').innerText = `${p2} / 7`; }
        function checkVictory() { const p1 = seals.filter(s => s.alignment === 'PURIFIED').length; const p2 = seals.filter(s => s.alignment === 'CORRUPTED').length; if (p1 === 7 || p2 === 7) showGameOver(p1 === 7 ? "THE GREAT ASCENSION" : "THE FINAL ECLIPSE", p1 === 7 ? "Utopia established. The Light prevails." : "The Void consumes all."); }
        function finalizeGame() { const p1 = seals.filter(s => s.alignment === 'PURIFIED').length; const p2 = seals.filter(s => s.alignment === 'CORRUPTED').length; showGameOver("CYCLE COMPLETE", p1 > p2 ? "Player 1 (Light) controls the majority." : "Player 2 (Darkness) controls the majority."); }
        function showGameOver(title, body) { currentPhase = 'GAME_OVER'; document.getElementById('msg-overlay').style.display = 'flex'; document.getElementById('msg-title').innerText = title; document.getElementById('msg-body').innerText = body; }

        function animate() {
            requestAnimationFrame(animate);
            if (camera && cameraTarget) camera.lookAt(cameraTarget);
            const time = Date.now() * 0.001;
            if (currentPhase === 'PREP') {
                playerHand.forEach(card => {
                    if (card && card.children && card.children[0]) {
                        const bodyMesh = card.children[0];
                        if (bodyMesh.material && card !== activeSelection) { bodyMesh.material.emissiveIntensity = 0.8 + Math.sin(time * 6) * 0.4; }
                    }
                });
            }
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
