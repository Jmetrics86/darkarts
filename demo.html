<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Seven - Deck Manifest Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #0a0a0f; font-family: 'Cinzel', serif; color: #e0e0e0; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        
        .hud-top { background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent); padding: 20px; display: flex; justify-content: space-between; pointer-events: auto; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .hud-bottom { background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); padding: 30px; display: flex; flex-direction: column; align-items: center; pointer-events: auto; }
        
        .alignment-panel { background: rgba(10, 10, 15, 0.8); padding: 10px 20px; border-radius: 5px; border: 1px solid #333; min-width: 150px; }
        .light-glow { box-shadow: 0 0 15px rgba(0, 242, 255, 0.4); border-color: #00f2ff; }
        .dark-glow { box-shadow: 0 0 15px rgba(255, 0, 68, 0.4); border-color: #ff0044; }

        .phase-banner { text-align: center; margin-bottom: 15px; }
        .phase-title { font-size: 1.8rem; letter-spacing: 6px; text-transform: uppercase; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.8); }
        .phase-step { font-size: 0.9rem; color: #00f2ff; font-weight: bold; letter-spacing: 2px; height: 20px; transition: opacity 0.3s; text-shadow: 0 0 5px #00f2ff; }

        .btn { background: #1a1a1a; color: white; border: 1px solid #555; padding: 12px 40px; cursor: pointer; font-family: inherit; transition: 0.3s; pointer-events: auto; letter-spacing: 2px; text-transform: uppercase; font-weight: bold; }
        .btn:hover:not(:disabled) { background: #333; border-color: #00f2ff; box-shadow: 0 0 20px rgba(0,242,255,0.6); color: #00f2ff; }
        .btn:disabled { opacity: 0.3; cursor: default; }

        .widget-panel { position: absolute; right: 20px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 15px; pointer-events: auto; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; border: 1px solid #444; }
        .control-group { display: flex; flex-direction: column; align-items: center; gap: 5px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .control-group:last-child { border-bottom: none; }
        .control-label { font-size: 0.6rem; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        .control-val { font-size: 0.8rem; color: #00f2ff; font-weight: bold; }
        .zoom-btn { width: 40px; height: 40px; background: rgba(0,0,0,0.7); border: 1px solid #00f2ff; color: #00f2ff; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; border-radius: 5px; cursor: pointer; transition: 0.3s; }
        .zoom-btn:hover { background: #00f2ff; color: #000; box-shadow: 0 0 10px #00f2ff; }

        #msg-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; backdrop-filter: blur(5px); }
        
        .seal-indicator-strip { position: absolute; top: 120px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        .seal-node { width: 12px; height: 12px; border-radius: 50%; border: 1px solid #444; background: #111; transition: 0.5s; }
        .node-purified { background: #00f2ff; box-shadow: 0 0 10px #00f2ff; border-color: #fff; }
        .node-corrupted { background: #ff0044; box-shadow: 0 0 10px #ff0044; border-color: #fff; }
        .node-active { transform: scale(1.5); border-color: #fff; }

        .tooltip { 
            position: absolute; 
            padding: 15px; 
            background: rgba(10,10,20,0.95); 
            border: 1px solid #00f2ff; 
            border-radius: 4px; 
            pointer-events: none; 
            opacity: 0; 
            transition: 0.2s; 
            font-size: 0.9rem; 
            z-index: 20; 
            color: #fff; 
            box-shadow: 0 0 15px rgba(0,242,255,0.4);
            min-width: 280px;
            max-width: 380px;
        }
        .tooltip-ability { 
            color: #8ff; 
            font-style: italic; 
            border-top: 1px solid rgba(255,255,255,0.1); 
            margin-top: 10px; 
            padding-top: 10px; 
            font-size: 0.8rem;
            line-height: 1.4;
        }
        .deck-counter { font-size: 0.6rem; color: #aaa; margin-top: 5px; letter-spacing: 1px; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="ui">
        <div class="hud-top">
            <div class="alignment-panel dark-glow">
                <div style="color: #ff0044; font-size: 0.7rem;">PLAYER 2 (DARKNESS)</div>
                <div id="p2-score" style="font-size: 1.8rem">0 / 7</div>
                <div id="p2-deck-count" class="deck-counter">DECK: 49</div>
            </div>
            <div style="text-align: center">
                <div id="round-indicator" style="font-size: 1.2rem; margin-bottom: 5px;">ROUND 1</div>
                <div id="game-status" style="font-size: 0.7rem; color: #aaa; text-transform: uppercase; letter-spacing: 1px;">Awaiting Command</div>
            </div>
            <div class="alignment-panel light-glow" style="text-align: right">
                <div style="color: #00f2ff; font-size: 0.7rem;">PLAYER 1 (LIGHT)</div>
                <div id="p1-score" style="font-size: 1.8rem">0 / 7</div>
                <div id="p1-deck-count" class="deck-counter">DECK: 49</div>
            </div>
        </div>

        <div class="seal-indicator-strip" id="seal-nodes">
            <div class="seal-node"></div><div class="seal-node"></div><div class="seal-node"></div>
            <div class="seal-node"></div><div class="seal-node"></div><div class="seal-node"></div>
            <div class="seal-node"></div>
        </div>

        <div class="widget-panel">
            <div class="control-group">
                <span class="control-label">Camera Zoom</span>
                <div style="display:flex; gap:5px">
                    <button class="zoom-btn" onclick="zoomCamera(-5)">+</button>
                    <button class="zoom-btn" onclick="zoomCamera(5)">−</button>
                </div>
            </div>
            <div class="control-group">
                <span class="control-label">Hand Tilt</span>
                <span id="val-tilt" class="control-val">0.85</span>
                <div style="display:flex; gap:5px">
                    <button class="zoom-btn" onclick="adjustTuning('tilt', 0.05)">+</button>
                    <button class="zoom-btn" onclick="adjustTuning('tilt', -0.05)">−</button>
                </div>
            </div>
            <div class="control-group">
                <span class="control-label">Hand Height</span>
                <span id="val-height" class="control-val">12.0</span>
                <div style="display:flex; gap:5px">
                    <button class="zoom-btn" onclick="adjustTuning('height', 0.5)">↑</button>
                    <button class="zoom-btn" onclick="adjustTuning('height', -0.5)">↓</button>
                </div>
            </div>
            <div class="control-group">
                <span class="control-label">Hand Distance</span>
                <span id="val-dist" class="control-val">21.0</span>
                <div style="display:flex; gap:5px">
                    <button class="zoom-btn" onclick="adjustTuning('dist', -0.5)">Forward</button>
                    <button class="zoom-btn" onclick="adjustTuning('dist', 0.5)">Back</button>
                </div>
            </div>
        </div>

        <div id="card-tooltip" class="tooltip"></div>

        <div class="hud-bottom">
            <div class="phase-banner">
                <div id="phase-step-label" class="phase-step"></div>
                <div id="phase-name-label" class="phase-title">Prep Phase</div>
            </div>
            <div id="instruction-text" style="color: #ddd; margin-bottom: 20px; font-style: italic; min-height: 1.2rem; text-shadow: 0 1px 2px #000;"></div>
            <button id="main-action-btn" class="btn">End Prep Phase</button>
        </div>
    </div>

    <div id="msg-overlay">
        <h1 id="msg-title" style="font-size: 3rem; margin: 0;"></h1>
        <p id="msg-body" style="font-size: 1.2rem; color: #aaa; max-width: 600px; text-align: center; margin: 20px 0;"></p>
        <button id="restart-btn" class="btn">Begin New Cycle</button>
    </div>

    <script>
        /**
         * ENDLESS SEVEN ENGINE - FULL MANIFEST DATA
         */
        const LIGHT_POOL = [
            { name: "The Spinner", faction: "Light", type: "Avatar", power: 9, isChampion: true, ability: "Flip: Gain +1 Power per Acolyte. Win Con: Activate with 4 Acolytes + Seal Champion." },
            { name: "The Allotter", faction: "Light", type: "Avatar", power: 9, isChampion: true, ability: "Flip: Destroy card on any Seal. Activate: Destroy any one Marker type." },
            { name: "Prophet", faction: "Light", type: "Avatar", power: 9, isChampion: true, ability: "Passive: Prevents Purified Seals from being Corrupted while in play." },
            { name: "The Inevitable", faction: "Light", type: "Avatar", power: 9, isChampion: true, ability: "Post-Combat: After destroying a creature, destroy one other card or Marker." },
            { name: "Saint Michael", faction: "Light", type: "Avatar", power: 10, isChampion: true, ability: "Win Con: Activate with 5+ Seals. Final Act: Move Limbo to Graveyard to destroy a card that battled." },
            { name: "Martyr", faction: "Light", type: "Avatar", power: 9, isChampion: true, ability: "Limbo Trigger: Purify one Neutral Seal without a Champion when entering Limbo." },
            { name: "The Almighty", faction: "Light", type: "God", power: 15, isChampion: true, ability: "Flip: Purify a Corrupted Seal without a Champion. Activate: Destroy any one Marker type." },
            { name: "Archangel", faction: "Celestial", type: "Creature", power: 2, isChampion: false, ability: "Flip: Reveal a face-down card; Nullify its Flip ability." },
            { name: "Cherubim", faction: "Celestial", type: "Creature", power: 4, isChampion: false, ability: "Flip: Return any creature in play to the top of its owner's deck." },
            { name: "Fallen One", faction: "Celestial", type: "Creature", power: 6, isChampion: false, ability: "Haste: Resolve battle before Flip. Final Act: Nullify any card ability activation." },
            { name: "Herald", faction: "Celestial", type: "Creature", power: 5, isChampion: false, ability: "Flip: Gain Power Markers equal to the Power Value of the deck's top card." },
            { name: "Nephilim", faction: "Celestial", type: "Creature", power: 3, isChampion: false, ability: "Flip: Battle invulnerability. Activate: Freeze Seal Influence until end of round." },
            { name: "Seraphim", faction: "Celestial", type: "Creature", power: 7, isChampion: false, ability: "Passive: Protects other Celestials from abilities while Championing a Seal." },
            { name: "Thrones", faction: "Angel", type: "Creature", power: 1, isChampion: false, ability: "Flip: Change Influence of any Seal without a Champion." },
            { name: "Alpha", faction: "Lycan", type: "Creature", power: 7, isChampion: false, ability: "Haste: Resolve combat first. Gain +2 Power after destroying an enemy." },
            { name: "Beta", faction: "Lycan", type: "Creature", power: 6, isChampion: false, ability: "Flip: Battle invulnerability. Action: +2 Power to adjacent creature." },
            { name: "Omega", faction: "Lycan", type: "Creature", power: 5, isChampion: false, ability: "Flip: +1 Power for every Lycan in Play and Limbo." },
            { name: "Sentinel", faction: "Lycan", type: "Creature", power: 4, isChampion: false, ability: "Flip: Copy Power Value of a creature in Limbo as Markers." },
            { name: "Delta", faction: "Lycan", type: "Creature", power: 3, isChampion: false, ability: "Flip: Buff 3 cards. Activate: Sacrifice at round end for +3 Power buff." },
            { name: "Luna", faction: "Lycan", type: "Creature", power: 2, isChampion: false, ability: "Final Act: Move to Graveyard to Nullify enemy Influence change." },
            { name: "Wild Wolf", faction: "Lycan", type: "Creature", power: 1, isChampion: false, ability: "Haste: Resolve combat first. Destroy battling creature at end of round." }
        ];

        const DARK_POOL = [
            { name: "Death", faction: "Darkness", type: "Avatar", power: 9, isChampion: true, ability: "Flip: Destroy all cards of a chosen type. Win Con: Activate with 4 Horsemen + Seal Champion." },
            { name: "Famine", faction: "Darkness", type: "Avatar", power: 9, isChampion: true, ability: "Flip: Destroy any card in play." },
            { name: "Pestilence", faction: "Darkness", type: "Avatar", power: 9, isChampion: true, ability: "Flip: Apply -2 Weakness per Horseman to all enemy creatures." },
            { name: "War", faction: "Darkness", type: "Avatar", power: 9, isChampion: true, ability: "Post-Combat: Gain +2 Power per Horseman in play after destroying a creature." },
            { name: "Lilith", faction: "Darkness", type: "Avatar", power: 10, isChampion: true, ability: "Win Con: Activate with 5+ Seals. Final Act: Move Limbo to Graveyard to destroy a card that battled." },
            { name: "Hades", faction: "Darkness", type: "Avatar", power: 9, isChampion: true, ability: "Flip: Gain +2 Power per Horseman. Move card from Limbo to top of Deck." },
            { name: "The Destroyer", faction: "Darkness", type: "God", power: 15, isChampion: true, ability: "Flip: Corrupt un-championed Purified Seals. Activate: Destroy all Markers of one type." },
            { name: "Wrath", faction: "Daemon", type: "Creature", power: 7, isChampion: false, ability: "Flip: Global -1 Weakness to enemies. Passive: Immune to creatures with Weakness." },
            { name: "Pride", faction: "Daemon", type: "Creature", power: 6, isChampion: false, ability: "Flip: -3 Weakness to card across. Action: +2 Power to adjacent creature." },
            { name: "Greed", faction: "Daemon", type: "Creature", power: 5, isChampion: false, ability: "Flip: Battle invulnerability. Activate: Siphon all Power Markers in play to self." },
            { name: "Sloth", faction: "Daemon", type: "Creature", power: 4, isChampion: false, ability: "Passive: Ability immune. Flip: -3 Weakness. Action: Destroy creature with Weakness." },
            { name: "Envy", faction: "Daemon", type: "Creature", power: 3, isChampion: false, ability: "Flip: -3 Weakness to any card with Power >= Envy." },
            { name: "Lust", faction: "Daemon", type: "Creature", power: 2, isChampion: false, ability: "Flip: Forced mutual sacrifice. Change Influence if Seal is empty." },
            { name: "Gluttony", faction: "Daemon", type: "Creature", power: 1, isChampion: false, ability: "Flip: Siphon all Power Markers in play to self." },
            { name: "Lord", faction: "Vampyre", type: "Creature", power: 7, isChampion: false, ability: "Flip: Spin Champion to top of deck. Activate: +1 Power per Vampyre in play." },
            { name: "Duke", faction: "Vampyre", type: "Creature", power: 6, isChampion: false, ability: "Flip: Spin creature to top of deck. Passive: Friendly cards count as Vampyre." },
            { name: "Elder", faction: "Vampyre", type: "Creature", power: 5, isChampion: false, ability: "Haste: Resolve combat first. Spin battling creature to top of deck." },
            { name: "Noble", faction: "Vampyre", type: "Creature", power: 4, isChampion: false, ability: "Flip: Destroy one creature. End of Turn: Gain +2 Power." },
            { name: "Regent", faction: "Vampyre", type: "Creature", power: 3, isChampion: false, ability: "Flip: Change Influence of any Seal without a Champion." },
            { name: "Baron", faction: "Vampyre", type: "Creature", power: 2, isChampion: false, ability: "Flip: Nullify Flip here. Action: Swap self with friendly Limbo card." },
            { name: "Fledgeling", faction: "Vampyre", type: "Creature", power: 1, isChampion: false, ability: "Passive: Cannot battle. Flip: +3 Power buff. Sacrifice at end of turn." }
        ];

        const SEVEN = 7;
        const SLOT_SPACING = 3.8;
        const CARD_W = 2.2;
        const CARD_H = 3.2;
        
        let tuning = { tilt: 0.85, height: 12.0, dist: 21.0 };
        let scene, camera, renderer, raycaster, mouse;
        let cameraTarget = new THREE.Vector3(0, 0, -2); 
        
        let seals = []; 
        let playerBattlefield = Array(SEVEN).fill(null);
        let enemyBattlefield = Array(SEVEN).fill(null);
        let playerHand = [];
        let playerLimbo = [];
        let enemyLimbo = [];

        // Logical Decks
        let playerDeck = [];
        let enemyDeck = [];
        
        let currentRound = 1;
        let currentPhase = 'PREP'; 
        let selectedObject = null;
        let activeSelection = null;
        let isProcessing = false;

        let playerDeckMesh, enemyDeckMesh, playerLimboMesh, enemyLimboMesh, floorMesh;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);
            scene.fog = new THREE.Fog(0x0a0a0f, 20, 100);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 28, 32);
            camera.lookAt(cameraTarget);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            setupLighting();
            createTabletop();
            
            // Build Initial Decks
            playerDeck = buildDeck(LIGHT_POOL, "Avatar", "God");
            enemyDeck = buildDeck(DARK_POOL, "Avatar", "God");

            startPrepPhase();

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);
            document.getElementById('main-action-btn').addEventListener('click', handleMainAction);
            document.getElementById('restart-btn').addEventListener('click', restartGame);

            animate();
        }

        /**
         * DECK LOGIC
         */
        function buildDeck(pool, singleTypeA, singleTypeB) {
            let deck = [];
            pool.forEach(card => {
                // Avatars and Gods are 1 copy. Everyone else is 3 copies.
                let copies = (card.type === singleTypeA || card.type === singleTypeB) ? 1 : 3;
                for (let i = 0; i < copies; i++) {
                    deck.push({ ...card });
                }
            });
            // Shuffle
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function setupLighting() {
            const amb = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(amb);
            const sky = new THREE.PointLight(0x00f2ff, 1.8, 150);
            sky.position.set(0, 30, 10);
            scene.add(sky);
            const rim = new THREE.DirectionalLight(0xffffff, 0.8);
            rim.position.set(-15, 30, -15);
            scene.add(rim);
            const playerLight = new THREE.PointLight(0xffffff, 1.0, 60);
            playerLight.position.set(0, 20, 25);
            scene.add(playerLight);
        }

        function createTabletop() {
            floorMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(400, 400),
                new THREE.MeshPhongMaterial({ color: 0x08080c, shininess: 20 })
            );
            floorMesh.rotation.x = -Math.PI/2;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);

            const startX = -(SEVEN - 1) * SLOT_SPACING / 2;

            for (let i = 0; i < SEVEN; i++) {
                const x = startX + i * SLOT_SPACING;
                const hub = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.2, 1.25, 0.25, 6),
                    new THREE.MeshPhongMaterial({ color: 0x222222, emissive: 0x080808 })
                );
                hub.position.set(x, 0.1, 0);
                scene.add(hub);

                const light = new THREE.PointLight(0xffffff, 0, 12);
                light.position.set(x, 2, 0);
                scene.add(light);

                seals.push({ mesh: hub, light, alignment: 'NEUTRAL', champion: null, index: i });
                createGridSlot(x, 3.2, 0x333333); 
                createGridSlot(x, -3.2, 0x333333);
            }

            const startOriginX = -(SEVEN - 1) * SLOT_SPACING / 2;
            const deckOffset = startOriginX - 4;
            const limboOffset = (startOriginX + (SEVEN - 1) * SLOT_SPACING) + 4;

            playerDeckMesh = createPile(0x0077aa);
            playerDeckMesh.position.set(deckOffset, 0.2, 6);
            scene.add(playerDeckMesh);
            addLabel(playerDeckMesh, "DECK", 0x00f2ff);

            enemyDeckMesh = createPile(0xaa2233);
            enemyDeckMesh.position.set(deckOffset, 0.2, -6);
            scene.add(enemyDeckMesh);
            addLabel(enemyDeckMesh, "DECK", 0xff0044);

            playerLimboMesh = createPile(0x444444);
            playerLimboMesh.position.set(limboOffset, 0.05, 6);
            scene.add(playerLimboMesh);
            addLabel(playerLimboMesh, "LIMBO", 0xcccccc);

            enemyLimboMesh = createPile(0x444444);
            enemyLimboMesh.position.set(limboOffset, 0.05, -6);
            scene.add(enemyLimboMesh);
            addLabel(enemyLimboMesh, "LIMBO", 0xcccccc);
        }

        function createGridSlot(x, z, color) {
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(CARD_W + 0.2, CARD_H + 0.2),
                new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
            );
            mesh.rotation.x = -Math.PI/2;
            mesh.position.set(x, 0.06, z);
            scene.add(mesh);
        }

        function createPile(color) {
            const group = new THREE.Group();
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(CARD_W + 0.3, 0.1, CARD_H + 0.3),
                new THREE.MeshPhongMaterial({ color: 0x000000, transparent: true, opacity: 0.7 })
            );
            group.add(base);

            for(let i=0; i<6; i++) {
                const layer = new THREE.Mesh(
                    new THREE.BoxGeometry(CARD_W, 0.05, CARD_H),
                    new THREE.MeshPhongMaterial({ color })
                );
                layer.position.y = 0.05 + (i * 0.06);
                layer.rotation.y = (Math.random() - 0.5) * 0.15;
                group.add(layer);
            }
            return group;
        }

        function addLabel(parent, text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128; // taller to hold numbers
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.font = 'bold 44px Cinzel';
            ctx.textAlign = 'center';
            ctx.fillText(text, 128, 48);
            
            // Placeholder for count
            ctx.font = 'bold 36px Arial';
            ctx.fillText("--", 128, 90);

            const tex = new THREE.CanvasTexture(canvas);
            const label = new THREE.Mesh(
                new THREE.PlaneGeometry(3.5, 1.75),
                new THREE.MeshBasicMaterial({ map: tex, transparent: true, color })
            );
            label.rotation.x = -Math.PI/2;
            label.position.y = 0.8;
            parent.add(label);
            parent.userData.labelCanvas = canvas;
            parent.userData.labelTexture = tex;
            parent.userData.labelText = text;
        }

        function updateDeckLabel(mesh, count) {
            if (!mesh.userData.labelCanvas) return;
            const ctx = mesh.userData.labelCanvas.getContext('2d');
            ctx.clearRect(0,0,256,128);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 44px Cinzel';
            ctx.textAlign = 'center';
            ctx.fillText(mesh.userData.labelText, 128, 48);
            ctx.font = 'bold 40px Arial';
            ctx.fillText(count, 128, 95);
            mesh.userData.labelTexture.needsUpdate = true;
        }

        function createCardMesh(data, isEnemy = false) {
            const group = new THREE.Group();
            const color = isEnemy ? 0x551111 : 0x113366;
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(CARD_W, 0.1, CARD_H),
                new THREE.MeshPhongMaterial({ color, emissive: color, emissiveIntensity: isEnemy ? 0.3 : 0.8 })
            );
            group.add(body);

            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 384;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = isEnemy ? '#200' : '#002';
            ctx.fillRect(0,0,256,384);
            ctx.strokeStyle = isEnemy ? '#f66' : '#6ff';
            ctx.lineWidth = 16;
            ctx.strokeRect(0,0,256,384);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 22px Cinzel';
            ctx.textAlign = 'center';
            ctx.fillText(data.name.toUpperCase(), 128, 50);
            
            ctx.font = '14px Cinzel';
            ctx.fillStyle = isEnemy ? '#f88' : '#8ff';
            ctx.fillText(data.faction, 128, 75);

            ctx.fillStyle = 'white';
            ctx.font = 'bold 100px Cinzel';
            ctx.shadowColor = 'rgba(0,0,0,0.8)';
            ctx.shadowBlur = 15;
            ctx.fillText(data.power, 128, 220);
            
            ctx.font = 'bold 30px Cinzel';
            ctx.fillText(data.isChampion ? 'CHAMPION' : data.type.toUpperCase(), 128, 310);

            const tex = new THREE.CanvasTexture(canvas);
            const label = new THREE.Mesh(
                new THREE.PlaneGeometry(CARD_W * 0.95, CARD_H * 0.95),
                new THREE.MeshBasicMaterial({ map: tex, transparent: true })
            );
            label.rotation.x = -Math.PI/2;
            label.position.y = 0.08;
            group.add(label);

            group.userData = { ...data, isEnemy, faceUp: false };
            return group;
        }

        async function startPrepPhase() {
            if (isProcessing) return;
            isProcessing = true;
            currentPhase = 'PREP';
            document.getElementById('phase-name-label').innerText = "Prep Phase";
            document.getElementById('main-action-btn').disabled = true;
            document.getElementById('main-action-btn').innerText = "Preparing...";
            
            updateStepLabel("Step 1: Draw Hand");
            document.getElementById('instruction-text').innerText = "Pulling from the deck of Light...";
            
            playerHand = []; 
            for (let i = 0; i < 8; i++) {
                if (playerDeck.length === 0) break;
                
                const cardData = playerDeck.pop();
                const card = createCardMesh(cardData, false);
                card.position.copy(playerDeckMesh.position);
                card.position.y += 2;
                scene.add(card);
                playerHand.push(card);
                
                const offset = (i - 3.5);
                const angle = offset * 0.06;
                const tx = offset * 2.15; 
                const tz = tuning.dist + (Math.abs(offset) * 0.3); 
                
                gsap.to(card.position, { x: tx, y: tuning.height, z: tz, duration: 0.6, ease: "power2.out" });
                gsap.to(card.rotation, { x: tuning.tilt, y: angle, z: 0, duration: 0.6 });
                
                updateUICounters();
                await sleep(100);
            }

            await sleep(300);
            updateStepLabel("Step 2: Shuffle Deck");
            document.getElementById('instruction-text').innerText = "Randomizing future possibilities.";
            await performShuffleAnimation();
            
            await sleep(300);
            updateStepLabel("Step 3: Strategic Reinforcement");
            document.getElementById('instruction-text').innerText = "Assign your units to the Seals.";
            document.getElementById('main-action-btn').disabled = false;
            document.getElementById('main-action-btn').innerText = "End Prep Phase";
            
            enemyReinforce();
            isProcessing = false;
        }

        async function performShuffleAnimation() {
            const layers = playerDeckMesh.children.filter(c => c.type === "Mesh" && c.geometry && c.geometry.type === "BoxGeometry");
            for(let i=0; i<4; i++) {
                layers.forEach((l) => {
                    gsap.to(l.position, { x: (Math.random() - 0.5) * 1.8, z: (Math.random() - 0.5) * 1.8, duration: 0.15, yoyo: true, repeat: 1 });
                });
                await sleep(150);
            }
        }

        function enemyReinforce() {
            const aiHandData = [];
            for (let i = 0; i < 8; i++) {
                if (enemyDeck.length > 0) aiHandData.push(enemyDeck.pop());
            }

            const vacantSlots = [];
            for (let i = 0; i < SEVEN; i++) { if (!enemyBattlefield[i]) vacantSlots.push(i); }

            vacantSlots.sort((a, b) => {
                const score = (idx) => {
                    const seal = seals[idx];
                    if (seal.alignment === 'PURIFIED') return 3;
                    if (seal.alignment === 'NEUTRAL') return 2;
                    return 1;
                };
                return score(b) - score(a);
            });

            for (let i = 0; i < vacantSlots.length && aiHandData.length > 0; i++) {
                const slotIdx = vacantSlots[i];
                aiHandData.sort((a, b) => b.power - a.power);
                const cardData = aiHandData.shift();

                const card = createCardMesh(cardData, true);
                card.position.copy(enemyDeckMesh.position);
                card.rotation.x = Math.PI;
                scene.add(card);
                enemyBattlefield[slotIdx] = card;

                gsap.to(card.position, { 
                    x: (slotIdx - 3) * SLOT_SPACING, 
                    y: 0.1, z: -3.2, 
                    duration: 0.8, delay: i * 0.15 
                });
            }
            updateUICounters();
        }

        function updateUICounters() {
            document.getElementById('p1-deck-count').innerText = `DECK: ${playerDeck.length}`;
            document.getElementById('p2-deck-count').innerText = `DECK: ${enemyDeck.length}`;
            updateDeckLabel(playerDeckMesh, playerDeck.length);
            updateDeckLabel(enemyDeckMesh, enemyDeck.length);
        }

        function handleMainAction() {
            if (currentPhase === 'PREP' && !isProcessing) endPrep();
        }

        function endPrep() {
            isProcessing = true;
            updateStepLabel("Finalizing Placements...");
            document.getElementById('instruction-text').innerText = "Purging excess units to Limbo.";
            playerHand.forEach((card, i) => {
                playerLimbo.push(card);
                gsap.to(card.position, { 
                    x: playerLimboMesh.position.x, 
                    y: 0.2 + (playerLimbo.length * 0.05), 
                    z: playerLimboMesh.position.z, 
                    duration: 0.6,
                    delay: i * 0.05,
                    onComplete: () => { 
                        card.rotation.set(0, 0, 0); 
                        if (card.children[0]) card.children[0].material.emissiveIntensity = 0.3; 
                    }
                });
            });
            playerHand = [];
            activeSelection = null;
            setTimeout(() => { startResolution(); }, 800);
        }

        async function startResolution() {
            currentPhase = 'RESOLUTION';
            document.getElementById('main-action-btn').disabled = true;
            document.getElementById('main-action-btn').innerText = "Resolving...";
            for (let i = 0; i < SEVEN; i++) { await resolveSeal(i); }
            checkVictory();
            if (currentPhase !== 'GAME_OVER') {
                currentRound++;
                document.getElementById('round-indicator').innerText = `ROUND ${currentRound}`;
                gsap.to(camera.position, { x: 0, y: 28, z: 32, duration: 1.5, ease: "power2.inOut" });
                gsap.to(cameraTarget, { x: 0, y: 0, z: -2, duration: 1.5, ease: "power2.inOut" });
                if (currentRound > 3) finalizeGame();
                else {
                    isProcessing = false;
                    startPrepPhase();
                }
            }
        }

        async function resolveSeal(idx) {
            const seal = seals[idx];
            const nodes = document.querySelectorAll('.seal-node');
            nodes.forEach(n => n.classList.remove('node-active'));
            nodes[idx].classList.add('node-active');
            document.getElementById('phase-name-label').innerText = `Seal ${idx + 1}`;
            gsap.to(camera.position, { x: seal.mesh.position.x, y: 14, z: 14, duration: 1 });
            gsap.to(cameraTarget, { x: seal.mesh.position.x, y: 0, z: 0, duration: 1 });
            let pCard = playerBattlefield[idx];
            let eCard = enemyBattlefield[idx];
            
            updateStepLabel("Step A: The Flip");
            if (pCard) gsap.to(pCard.rotation, { x: 0, duration: 0.5 });
            if (eCard) gsap.to(eCard.rotation, { x: 0, duration: 0.5 });
            await sleep(800);

            updateStepLabel("Step C: Battle");
            if (pCard && seal.champion && seal.champion.userData.isEnemy) {
                const pPower = pCard.userData.power;
                const cPower = seal.champion.userData.power;
                if (pPower > cPower) {
                    destroyToLimbo(seal.champion, true, idx, true);
                    seal.champion = null;
                } else if (pPower < cPower) {
                    destroyToLimbo(pCard, false, idx);
                    pCard = null;
                } else {
                    destroyToLimbo(seal.champion, true, idx, true);
                    destroyToLimbo(pCard, false, idx);
                    seal.champion = null; pCard = null;
                }
                await sleep(500);
            }
            if (eCard && seal.champion && !seal.champion.userData.isEnemy) {
                const ePower = eCard.userData.power;
                const cPower = seal.champion.userData.power;
                if (ePower > cPower) {
                    destroyToLimbo(seal.champion, false, idx, true);
                    seal.champion = null;
                } else if (ePower < cPower) {
                    destroyToLimbo(eCard, true, idx);
                    eCard = null;
                } else {
                    destroyToLimbo(seal.champion, false, idx, true);
                    destroyToLimbo(eCard, true, idx);
                    seal.champion = null; eCard = null;
                }
                await sleep(500);
            }
            if (pCard && eCard) {
                const pPower = pCard.userData.power;
                const ePower = eCard.userData.power;
                if (pPower > ePower) {
                    destroyToLimbo(eCard, true, idx);
                    eCard = null; await handlePostBattleSiege(idx, pPower, true);
                } else if (ePower > pPower) {
                    destroyToLimbo(pCard, false, idx);
                    pCard = null; await handlePostBattleSiege(idx, ePower, false);
                } else {
                    destroyToLimbo(pCard, false, idx);
                    destroyToLimbo(eCard, true, idx);
                    pCard = null; eCard = null;
                }
            } else if (pCard) { await handlePostBattleSiege(idx, pCard.userData.power, true);
            } else if (eCard) { await handlePostBattleSiege(idx, eCard.userData.power, false);
            } else { await handlePostBattleSiege(idx, 0, true); }
            await sleep(600);

            updateStepLabel("Step E: Ascension");
            const survivor = (playerBattlefield[idx]) ? playerBattlefield[idx] : ((enemyBattlefield[idx]) ? enemyBattlefield[idx] : null);
            if (survivor && survivor.userData.isChampion && !seal.champion) {
                ascendToSeal(survivor, idx);
            }
            await sleep(1000);
        }

        async function handlePostBattleSiege(idx, attackerPower, isPlayer) {
            const seal = seals[idx];
            const attacker = isPlayer ? playerBattlefield[idx] : enemyBattlefield[idx];
            if (seal.champion && seal.champion.userData.isEnemy === isPlayer) {
                const champPower = seal.champion.userData.power;
                if (attackerPower > champPower) {
                    destroyToLimbo(seal.champion, !isPlayer, idx, true);
                    seal.champion = null;
                    claimSeal(idx, isPlayer ? 'PURIFIED' : 'CORRUPTED');
                } else if (attackerPower < champPower) {
                    if (attacker) destroyToLimbo(attacker, !isPlayer, idx);
                } else if (attackerPower === champPower && attackerPower > 0) {
                    destroyToLimbo(seal.champion, !isPlayer, idx, true);
                    if (attacker) destroyToLimbo(attacker, !isPlayer, idx);
                    seal.champion = null; claimSeal(idx, 'NEUTRAL');
                }
            } else if (!seal.champion && attackerPower > 0) {
                claimSeal(idx, isPlayer ? 'PURIFIED' : 'CORRUPTED');
            }
        }

        function destroyToLimbo(card, isEnemy, idx, isChamp = false) {
            const limboPile = isEnemy ? enemyLimbo : playerLimbo;
            const limboMesh = isEnemy ? enemyLimboMesh : playerLimboMesh;
            limboPile.push(card);
            if (!isChamp) { if (isEnemy) enemyBattlefield[idx] = null; else playerBattlefield[idx] = null; }
            gsap.to(card.position, { x: limboMesh.position.x + (Math.random()-0.5), y: 0.2 + (limboPile.length * 0.05), z: limboMesh.position.z + (Math.random()-0.5), duration: 0.8, ease: "power2.inOut" });
            gsap.to(card.rotation, { x: 0, y: Math.random() * 0.5, z: 0, duration: 0.8 });
            if (card.children[0]) card.children[0].material.emissiveIntensity = 0.3;
        }

        function claimSeal(idx, status) {
            const seal = seals[idx];
            seal.alignment = status;
            let color = 0x080808; 
            if (status === 'PURIFIED') color = 0x00f2ff;
            if (status === 'CORRUPTED') color = 0xff0044;
            seal.mesh.material.emissive.setHex(color);
            seal.mesh.material.emissiveIntensity = status === 'NEUTRAL' ? 0.1 : 0.8;
            seal.light.color.setHex(color);
            seal.light.intensity = status === 'NEUTRAL' ? 0 : 3.5;
            document.querySelectorAll('.seal-node')[idx].className = 'seal-node ' + (status === 'PURIFIED' ? 'node-purified' : (status === 'CORRUPTED' ? 'node-corrupted' : ''));
            updateGlobalScores();
        }

        function ascendToSeal(card, idx) {
            if (card.userData.isEnemy) enemyBattlefield[idx] = null; else playerBattlefield[idx] = null;
            seals[idx].champion = card;
            gsap.to(card.position, { x: seals[idx].mesh.position.x, y: 0.6, z: 0, duration: 0.6, ease: "back.out" });
            if (card.children[0]) card.children[0].material.emissiveIntensity = 1.0;
        }

        function zoomCamera(val) { gsap.to(camera.position, { y: camera.position.y + (val * 0.7), z: camera.position.z + val, duration: 0.5, ease: "power2.out" }); }
        function adjustTuning(key, delta) { tuning[key] = parseFloat((tuning[key] + delta).toFixed(2)); document.getElementById(`val-${key}`).innerText = tuning[key]; rearrangeHand(); }

        function restartGame() {
            document.getElementById('msg-overlay').style.display = 'none';
            [...playerHand, ...playerLimbo, ...enemyLimbo, ...playerBattlefield, ...enemyBattlefield].forEach(card => { if (card) scene.remove(card); });
            seals.forEach(seal => { if (seal.champion) scene.remove(seal.champion); seal.champion = null; seal.alignment = 'NEUTRAL'; seal.mesh.material.emissive.setHex(0x080808); seal.light.intensity = 0; });
            document.querySelectorAll('.seal-node').forEach(node => node.className = 'seal-node');
            playerBattlefield = Array(SEVEN).fill(null); enemyBattlefield = Array(SEVEN).fill(null);
            playerHand = []; playerLimbo = []; enemyLimbo = []; currentRound = 1;
            
            // Regenerate Decks
            playerDeck = buildDeck(LIGHT_POOL, "Avatar", "God");
            enemyDeck = buildDeck(DARK_POOL, "Avatar", "God");

            document.getElementById('round-indicator').innerText = `ROUND 1`;
            document.getElementById('p1-score').innerText = `0 / 7`; document.getElementById('p2-score').innerText = `0 / 7`;
            gsap.to(camera.position, { x: 0, y: 28, z: 32, duration: 1.5 }); cameraTarget.set(0, 0, -2);
            isProcessing = false;
            updateUICounters();
            startPrepPhase();
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const allCards = [
                ...playerHand, 
                ...playerBattlefield.filter(c => c !== null), 
                ...enemyBattlefield.filter(c => c !== null),
                ...seals.map(s => s.champion).filter(c => c !== null)
            ];
            
            const intersects = raycaster.intersectObjects(allCards, true);
            const tooltip = document.getElementById('card-tooltip');
            
            if (intersects.length > 0) {
                let card = intersects[0].object;
                while (card.parent && !allCards.includes(card)) card = card.parent;
                
                if (selectedObject !== card) {
                    if (selectedObject && playerHand.includes(selectedObject)) gsap.to(selectedObject.position, { y: tuning.height, duration: 0.2 });
                    if (playerHand.includes(card)) gsap.to(card.position, { y: tuning.height + 1.5, duration: 0.2 });
                    
                    selectedObject = card;
                    tooltip.style.opacity = 1; 
                    tooltip.style.left = event.clientX + 20 + 'px'; 
                    tooltip.style.top = event.clientY - 40 + 'px';
                    
                    const data = card.userData;
                    tooltip.innerHTML = `
                        <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;">${data.name}</div>
                        <div style="color: ${data.isEnemy ? '#f88' : '#8ff'}; font-size: 0.7rem; letter-spacing: 1px; margin-bottom: 5px;">
                            ${data.faction.toUpperCase()} / ${data.isChampion ? 'CHAMPION' : data.type.toUpperCase()}
                        </div>
                        <div style="font-size: 1.2rem; font-weight: bold; margin: 10px 0;">POWER: ${data.power}</div>
                        <div class="tooltip-ability">${data.ability}</div>
                    `;
                }
            } else {
                if (selectedObject && playerHand.includes(selectedObject)) gsap.to(selectedObject.position, { y: tuning.height, duration: 0.2 });
                selectedObject = null; 
                tooltip.style.opacity = 0;
            }
        }

        function onMouseDown() {
            if (currentPhase !== 'PREP' || isProcessing) return;
            raycaster.setFromCamera(mouse, camera);
            const handIntersects = raycaster.intersectObjects(playerHand, true);
            if (handIntersects.length > 0) {
                let card = handIntersects[0].object;
                while (card.parent && !playerHand.includes(card)) card = card.parent;
                if (activeSelection && activeSelection.children[0]) activeSelection.children[0].material.emissiveIntensity = 0.8;
                activeSelection = card; if (activeSelection.children[0]) activeSelection.children[0].material.emissiveIntensity = 2.5;
                return;
            }
            if (activeSelection) {
                const tableIntersects = raycaster.intersectObjects([floorMesh]);
                if (tableIntersects.length > 0) {
                    const intersect = tableIntersects[0];
                    if (intersect.point.z > 0.5 && intersect.point.z < 7.0) {
                        const startX = -(SEVEN - 1) * SLOT_SPACING / 2;
                        const idx = Math.round((intersect.point.x - startX) / SLOT_SPACING);
                        if (idx >= 0 && idx < SEVEN && !playerBattlefield[idx]) {
                            const card = activeSelection; playerHand = playerHand.filter(c => c !== card); playerBattlefield[idx] = card;
                            gsap.to(card.position, { x: (idx - 3) * SLOT_SPACING, y: 0.1, z: 3.2, duration: 0.5, ease: "power2.inOut" });
                            gsap.to(card.rotation, { x: Math.PI, y: 0, z: 0, duration: 0.5 });
                            if (card.children[0]) card.children[0].material.emissiveIntensity = 0.4;
                            activeSelection = null; rearrangeHand();
                        }
                    }
                }
            }
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        function updateStepLabel(txt) { const el = document.getElementById('phase-step-label'); el.style.opacity = 0; setTimeout(() => { el.innerText = txt; el.style.opacity = 1; }, 200); }
        function updateGlobalScores() {
            const p1 = seals.filter(s => s.alignment === 'PURIFIED').length;
            const p2 = seals.filter(s => s.alignment === 'CORRUPTED').length;
            document.getElementById('p1-score').innerText = `${p1} / 7`; document.getElementById('p2-score').innerText = `${p2} / 7`;
        }
        function checkVictory() {
            const p1 = seals.filter(s => s.alignment === 'PURIFIED').length;
            const p2 = seals.filter(s => s.alignment === 'CORRUPTED').length;
            if (p1 === 7 || p2 === 7) showGameOver(p1 === 7 ? "THE GREAT ASCENSION" : "THE FINAL ECLIPSE", p1 === 7 ? "Utopia established. The Light prevails." : "The Void consumes all.");
        }
        function finalizeGame() {
            const p1 = seals.filter(s => s.alignment === 'PURIFIED').length;
            const p2 = seals.filter(s => s.alignment === 'CORRUPTED').length;
            showGameOver("CYCLE COMPLETE", p1 > p2 ? "Player 1 (Light) controls the majority." : "Player 2 (Darkness) controls the majority.");
        }
        function showGameOver(title, body) { currentPhase = 'GAME_OVER'; document.getElementById('msg-overlay').style.display = 'flex'; document.getElementById('msg-title').innerText = title; document.getElementById('msg-body').innerText = body; }

        function animate() {
            requestAnimationFrame(animate);
            if (camera && cameraTarget) camera.lookAt(cameraTarget);
            const time = Date.now() * 0.001;
            if (currentPhase === 'PREP') {
                playerHand.forEach(card => {
                    if (card && card.children && card.children[0]) {
                        const bodyMesh = card.children[0];
                        if (bodyMesh.material && card !== activeSelection) {
                            bodyMesh.material.emissiveIntensity = 0.8 + Math.sin(time * 6) * 0.4;
                        }
                    }
                });
            }
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
